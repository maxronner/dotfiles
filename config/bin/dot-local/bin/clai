#!/usr/bin/env bash
set -euo pipefail

# Configuration with defaults
PREPROMPT=${LLM_PREPROMPT:-"Keep it dense, concise and informative without going off-topic. Output should be in plaintext or markdown. Add +1 # when using #"}
PROVIDER=${LLM_PROVIDER:-"gemini"}

case "$PROVIDER" in
  gemini)
    MODEL="${LLM_MODEL:-"gemini-flash-latest"}"
    API_KEY="${LLM_KEY:-$GEMINI_API_KEY}"
    ;;
  openai)
    MODEL="${LLM_MODEL:-"gpt-5.2"}"
    API_KEY="${LLM_KEY:-$OPENAI_API_KEY}"
    ;;
  claude)
    MODEL="${LLM_MODEL:-"claude-haiku-4-5"}"
    API_KEY="${LLM_KEY:-$ANTHROPIC_API_KEY}"
    ;;
  *)
    echo "fatal: provider '$PROVIDER' is not supported" >&2
    exit 1
    ;;
esac

if [[ -z "$API_KEY" ]]; then
  echo "error: LLM_KEY is not set" >&2
  exit 1
fi

# Parse arguments
state_name=""
state_path=""
want_clear=false
list_states=false
args=()
prompt=""
combined_prompt=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -s|--state)
      if [[ -z "${2:-}" || "${2:0:1}" == "-" ]]; then
        list_states=true
        shift
      else
        state_name="$2"
        shift 2
      fi
      ;;
    -c|--clear)
      want_clear=true
      shift
      ;;
    -p|--preprompt)
      PREPROMPT="$2"
      shift 2
      ;;

    --)
      shift
      args+=("$@")
      break
      ;;
    *)
      args+=("$1")
      shift
      ;;
  esac
done

init_state() {
  [[ -z "$state_name" ]] && return

  local state_root="${XDG_STATE_HOME:-$HOME/.local/state}"
  local state_dir="$state_root/llm"
  mkdir -p "$state_dir"

  [[ "$state_name" != *.md ]] && state_name="${state_name}.md"
  state_path="$state_dir/$state_name"
}

list_states() {
  local state_root state_dir entries ts name pretty
  state_root="${XDG_STATE_HOME:-$HOME/.local/state}"
  state_dir="$state_root/llm"
  mkdir -p "$state_dir"

  entries=$(find "$state_dir" -maxdepth 1 -type f -name "*.md" -printf '%T@\t%f\n' 2>/dev/null | sort -nr)
  if [[ -z "$entries" ]]; then
    echo "no saved states" >&2
    return 0
  fi

  while IFS=$'\t' read -r ts name; do
    [[ -z "$ts" ]] && continue
    pretty=$(date -d "@${ts%.*}" +"%Y-%m-%d %H:%M")
    printf "%s  %s\n" "$pretty" "$name"
  done <<<"$entries"
}

clear_state() {
  if [[ -z "$state_path" ]]; then
    echo "error: --clear requires --state <name>" >&2
    exit 1
  fi
  rm -f "$state_path"
}

build_prompt() {
  prompt=$(printf "%s " "${args[@]}")
  prompt=${prompt% }  # Remove trailing space

  if [[ -z "$prompt" ]]; then
    echo "error: prompt is empty" >&2
    exit 1
  fi

  # Prepend state history if it exists
  if [[ -n "$state_path" && -f "$state_path" ]]; then
    combined_prompt=$(<"$state_path")$'\n\n'"$prompt"
  else
    combined_prompt="$prompt"
  fi
}

call_claude() {
  local payload api_response text

  payload=$(jq -n \
    --arg model "$MODEL" \
    --arg content "$PREPROMPT"$'\n\n'"$combined_prompt" \
    '{
      model: $model,
      max_tokens: 5000,
      messages: [{
        role: "user",
        content: $content
      }]
  }')
if ! api_response=$(curl -sS https://api.anthropic.com/v1/messages \
  -H "Content-Type: application/json" \
  -H "x-api-key: $API_KEY" \
  -H "anthropic-version: 2023-06-01" \
  -d "$payload"); then
echo "error: claude API request failed" >&2
return 1
fi

text=$(jq -r '.content[0].text // empty' <<<"$api_response")

if [[ -z "$text" ]]; then
  local err
  err=$(jq -r '.error.message // .error // empty' <<<"$api_response")
  if [[ -n "$err" ]]; then
    echo "error: $err" >&2
  else
    echo "error: failed to parse claude response" >&2
  fi
  return 1
fi

printf "%s\n" "$text"
}

call_tgpt() {
  tgpt \
    --provider "$PROVIDER" \
    --preprompt "$PREPROMPT" \
    --key "$API_KEY" \
    --model "$MODEL" \
    -- "$combined_prompt" | \
    sed '/^.*[[:space:]][[:space:]]Loading/d'
  }

save_to_state() {
  [[ -z "$state_path" ]] && return

  {
    printf "## Me:\n%s\n\n" "$prompt"
    printf "## Model:\n%s\n\n" "$response"
  } >> "$state_path"
}

main() {
  init_state

  # Handle --clear flag
  if [[ "$want_clear" == true ]]; then
    clear_state
    [[ ${#args[@]} -eq 0 ]] && exit 0
  fi

  # Display state history if no prompt given
  if [[ ${#args[@]} -eq 0 ]]; then
    if [[ "$list_states" == true ]]; then
      list_states
      exit 0
    fi
    if [[ -n "$state_path" && -f "$state_path" ]]; then
      glow "$state_path"
    fi
    exit 0
  fi

  build_prompt

  # Call appropriate provider
  case "$PROVIDER" in
    gemini|openai)
      response=$(call_tgpt)
      ;;
    claude)
      response=$(call_claude)
      ;;
    *)
      echo "fatal: provider '$PROVIDER' is not supported" >&2
      exit 1
      ;;
  esac

  save_to_state
  printf "%s\n" "$response" | glow
}

main
